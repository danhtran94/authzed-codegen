package generator

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/danhtran94/authzed-codegen/internal/ast"
	"github.com/danhtran94/authzed-codegen/internal/utilstr"
)

var SOURCE_HEADER = "// Code generated by spicedb-gen, DO NOT EDIT.\n\n"

type Generator struct {
	Definitions     []*ast.DefinitionNode
	ObjectTemplates map[string]string

	OutputPath string
}

func NewGenerator(definitions []*ast.DefinitionNode) *Generator {
	return &Generator{Definitions: definitions, ObjectTemplates: make(map[string]string)}
}

func (g *Generator) AddObjectTemplate(name, template string) {
	g.ObjectTemplates[name] = template
}

func (g *Generator) GenerateObjectSource(name string) error {
	tmplStr := g.ObjectTemplates[name]

	defs := ParseDefinitions(g.Definitions)
	tree := defs.GetPermissionTree()

	var mapFuncs = template.FuncMap{
		"upperFirst":              utilstr.UpperFirst,
		"packageName":             utilstr.PackageName,
		"snakeToPascal":           utilstr.SnakeToPascal,
		"typeName":                utilstr.TypeName,
		"relationExpressionTypes": flattenRelationExpressionTypeStrings,
		"permissionInputTypes": func(objectType string, perm string) []string {
			treename := fmt.Sprintf("%s/%s", objectType, perm)
			if types, ok := tree[treename]; ok {
				return types
			}

			return []string{}
		},
	}

	tmpl := template.New(name).Funcs(mapFuncs)

	tmpl, err := tmpl.Parse(tmplStr)
	if err != nil {
		return err
	}

	for _, def := range g.Definitions {
		path := fmt.Sprintf("%s/%s", g.OutputPath, utilstr.PackageName(def.ObjectType.Prefix))
		err := os.MkdirAll(path, os.ModePerm)
		if err != nil {
			return err
		}
	}

	for _, def := range g.Definitions {
		buf := bytes.Buffer{}

		_, err := buf.WriteString(SOURCE_HEADER)
		if err != nil {
			return err
		}

		err = tmpl.Execute(&buf, struct {
			*ast.DefinitionNode
		}{
			DefinitionNode: def,
		})
		if err != nil {
			return nil
		}

		filePath := fmt.Sprintf("%s/%s/%s.gen.go", g.OutputPath, utilstr.PackageName(def.ObjectType.Prefix), utilstr.PackageName(def.ObjectType.Name))
		err = os.WriteFile(filePath, buf.Bytes(), os.ModePerm)
		if err != nil {
			return err
		}
	}

	return nil
}

type Permission struct {
	Types []string
	Kind  string
	Value string
}
type Relation struct {
	Types []string
	Kind  string
	Value string
}

type Permissions []Permission
type PermissionsByNames map[string]Permissions

func (p PermissionsByNames) IsEmpty() bool {
	return len(p) == 0
}

func (p PermissionsByNames) Get(permission string) (bool, Permissions) {
	if perms, ok := p[permission]; ok {
		return true, perms
	}

	return false, []Permission{}
}

type Relations []Relation
type RelationsByNames map[string]Relations

func (r RelationsByNames) Get(relation string) (bool, Relations) {
	if rels, ok := r[relation]; ok {
		return true, rels
	}

	return false, []Relation{}
}

func (r Relations) Types() []string {
	types := []string{}
	for _, rel := range r {
		types = append(types, rel.Types...)
	}

	return types
}

type Definition struct {
	Type        string
	Permissions PermissionsByNames
	Relations   RelationsByNames
}
type DefinitionsByTypes map[string]*Definition

func (d DefinitionsByTypes) GetPermissionTree() map[string][]string {
	// We want to convert the definitions into a tree of permissions without soft relations
	tree := map[string][]string{}
	seen := map[string]bool{}

	addTree := func(treename string, types []string) {
		for _, t := range types {
			seenname := fmt.Sprintf("%s/%s", treename, t)
			if _, ok := seen[seenname]; !ok {
				seen[seenname] = true
				tree[treename] = append(tree[treename], t)
			}
		}
	}

	// Creating a relation resolver that helps to resolve the relation types
	relationResolver := map[string][]string{}
	for t, def := range d {
		if def.Permissions.IsEmpty() {
			tree[t] = []string{}
		}

		for n, permissions := range def.Permissions {
			for _, p := range permissions {
				if p.Kind == "relation" {
					treename := fmt.Sprintf("%s/%s", t, n)
					relationResolver[treename] = p.Types
				}
			}
		}
	}

	// We will find all references of the relations and permissions
	for t, def := range d {
		for n, permissions := range def.Permissions {
			for _, p := range permissions {
				treename := fmt.Sprintf("%s/%s", t, n)
				if p.Kind == "permission" {
					// This is a permission that references another permission
					for _, ref := range p.Types {
						refperm := fmt.Sprintf("%s/%s", ref, p.Value)
						// We need to resolve the relation types by using the relationResolver
						// tree[treename] = append(tree[treename], relationResolver[refperm]...)
						addTree(treename, relationResolver[refperm])
					}
				} else {
					// tree[treename] = append(tree[treename], p.Types...)
					addTree(treename, p.Types)
				}
			}
		}
	}

	return tree
}

func ParseDefinitions(defs []*ast.DefinitionNode) DefinitionsByTypes {

	defsByTypes := DefinitionsByTypes{}

	for _, d := range defs {
		objectType := d.ObjectType.String()
		_permissions := PermissionsByNames{}
		_relations := RelationsByNames{}

		for _, p := range d.Permissions {
			_permissions[p.Name] = Permissions{}
		}

		for _, r := range d.Relations {
			_relations[r.Name] = flattenRelationExpressionTypes(r.Expression)
		}

		defsByTypes[objectType] = &Definition{
			Type:        objectType,
			Permissions: _permissions,
			Relations:   _relations,
		}
	}

	for _, d := range defs {
		objectType := d.ObjectType.String()
		_permissions := PermissionsByNames{}

		for _, p := range d.Permissions {
			_permissions[p.Name] = resolvePermissionExpressionTypes(p.Expression, ResolveArgs{
				ObjectType:  objectType,
				Definitions: defsByTypes,
			})
		}

		defsByTypes[objectType].Permissions = _permissions
	}

	return defsByTypes
}

func flattenRelationExpressionTypeStrings(node ast.RelationExpressionNode) []string {
	result := []string{}

	for _, r := range flattenRelationExpressionTypes(node) {
		result = append(result, r.Types...)
	}

	return result
}

func flattenRelationExpressionTypes(node ast.RelationExpressionNode) []Relation {
	result := []Relation{}

	switch node.(type) {
	case *ast.SingleRelationNode:
		cast := node.(*ast.SingleRelationNode)
		result = append(result, Relation{
			Types: []string{cast.Value},
			Kind:  "single",
			Value: cast.Value,
		})
	case *ast.UnionRelationNode:
		cast := node.(*ast.UnionRelationNode)
		if cast.Left != nil {
			result = append(result, flattenRelationExpressionTypes(cast.Left)...)
		}
		if cast.Right != nil {
			result = append(result, flattenRelationExpressionTypes(cast.Right)...)
		}
	}

	return result
}

type ResolveArgs struct {
	ObjectType  string
	Definitions DefinitionsByTypes
}

func resolvePermissionExpressionTypes(node ast.PermissionExpressionNode, args ResolveArgs) []Permission {
	permissions := []Permission{}

	_relations := args.Definitions[args.ObjectType].Relations
	_permissions := args.Definitions[args.ObjectType].Permissions

	switch node.(type) {
	case *ast.IdentifierNode:
		cast := node.(*ast.IdentifierNode)
		if ok, rels := _relations.Get(cast.Value); ok { // a permission can be a relation
			permissions = append(permissions, Permission{
				Types: rels.Types(),
				Kind:  "relation",
				Value: cast.Value,
			})
		} else if ok, _ := _permissions.Get(cast.Value); ok { // or an other permission in the same object type
			permissions = append(permissions, Permission{
				Types: []string{args.ObjectType},
				Kind:  "permission",
				Value: cast.Value,
			})
		}

	case *ast.BinaryOpNode:
		cast := node.(*ast.BinaryOpNode)
		if cast.Operator == "->" {
			// This is the "->" operator
			// We need to resolve the left side of the expression
			// and get the permission from the right side of the expression

			permission := cast.Right.String()

			_, relations := _relations.Get(cast.Left.String())
			for _, referenceType := range relations.Types() {
				ok, _ := args.Definitions[referenceType].Permissions.Get(permission)
				if ok {
					permissions = append(permissions, Permission{
						Types: []string{referenceType}, // the type of the another object's permission
						Kind:  "permission",
						Value: permission,
					})
				}
			}
		} else {
			// This is the "+" operator
			// We need to resolve the left and right side of the expression
			// and combine the results

			if cast.Left != nil {
				permissions = append(permissions, resolvePermissionExpressionTypes(cast.Left, args)...)
			}
			if cast.Right != nil {
				permissions = append(permissions, resolvePermissionExpressionTypes(cast.Right, args)...)
			}
		}
	}

	deduped := []Permission{}
	seen := map[string]bool{}
	for _, p := range permissions {
		uniq := strings.Join(p.Types, ",") + p.Kind + p.Value
		if _, ok := seen[uniq]; !ok {
			seen[uniq] = true
			deduped = append(deduped, p)
		}
	}

	return deduped
}
